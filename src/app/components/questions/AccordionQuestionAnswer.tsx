'use client';

import { useState, useEffect, useRef } from 'react';
import ReactMarkdown from 'react-markdown';
import { BookmarkButton } from './BookmarkButton';
import { isQuestionBookmarked } from '@/app/utils/progress';
import { Accordion, AccordionItem, AccordionTrigger, AccordionContent, useAccordionItem } from "@/app/components/ui/radix-accordion";

// Define QuestionType locally based on usage in topics/page.tsx
type QuestionType = {
  id: number;
  question_text: string;
  answer_text?: string | null;
  keywords?: string[] | string | null;
  difficulty?: string | null;
  category_id?: number | null;
};

interface AccordionQuestionAnswerProps {
  questions: QuestionType[];
}

export function AccordionQuestionAnswer({ questions }: AccordionQuestionAnswerProps) {
  return (
    <Accordion
      type="single"
      collapsible
      className="w-full"
    >
      {questions.map((question, index) => (
        <QuestionItem
          key={question.id || index}
          question={question}
          questionIndex={index}
          value={`question-${question.id || index}`}
        />
      ))}
    </Accordion>
  );
}

interface QuestionItemProps {
  question: QuestionType;
  questionIndex: number;
  value: string;
}

function QuestionItem({ question, questionIndex, value }: QuestionItemProps) {
  const [isGenerating, setIsGenerating] = useState(false);
  const [generatedAnswer, setGeneratedAnswer] = useState<string | null>(null);
  const [error, setError] = useState<string | null>(null);
  const [isViewed, setIsViewed] = useState(false);
  const [isBookmarked, setIsBookmarked] = useState(false);
  const [scrollProgress, setScrollProgress] = useState(0);
  const answerRef = useRef<HTMLDivElement>(null);
  const scrollTimeoutRef = useRef<NodeJS.Timeout | null>(null);

  // Determine if the existing answer is actual content or placeholder
  const hasPredefinedAnswer = question.answer_text &&
                             !question.answer_text.toLowerCase().includes('generated by ai');

  // Check if question is bookmarked when component mounts
  useEffect(() => {
    if (question.id) {
      isQuestionBookmarked(question.id)
        .then(bookmarked => setIsBookmarked(bookmarked))
        .catch(err => console.error('Failed to check bookmark status:', err));
    }
  }, [question.id]);

  // Track scroll progress in the answer content
  useEffect(() => {
    const answerElement = answerRef.current;
    if (!answerElement) return;

    const handleScroll = () => {
      if (scrollTimeoutRef.current) {
        clearTimeout(scrollTimeoutRef.current);
      }

      scrollTimeoutRef.current = setTimeout(() => {
        const { scrollTop, scrollHeight, clientHeight } = answerElement;
        const scrolled = (scrollTop / (scrollHeight - clientHeight)) * 100;
        setScrollProgress(Math.min(Math.max(scrolled, 0), 100));

        // Mark as viewed when scrolled more than 70%
        if (scrolled > 70 && !isViewed && question.id) {
          setIsViewed(true);
          // Here you would call your API to update progress
          // updateQuestionProgress(question.id, 'completed');
        }
      }, 100);
    };

    answerElement.addEventListener('scroll', handleScroll);
    return () => {
      if (scrollTimeoutRef.current) {
        clearTimeout(scrollTimeoutRef.current);
      }
      answerElement?.removeEventListener('scroll', handleScroll);
    };
  }, [question.id, isViewed]);

  // Fetch generated answer when expanded, if applicable
  const generateAnswer = async () => {
    if (hasPredefinedAnswer || generatedAnswer || isGenerating) return;

    setIsGenerating(true);
    setError(null);
    try {
      console.log(`Generating answer for question: ${question.id} - ${question.question_text}`);
      const response = await fetch('/api/generate-answer', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          questionText: question.question_text,
          questionId: question.id,
        }),
      });

      if (!response.ok) {
        throw new Error(`API error: ${response.status}`);
      }

      const data = await response.json();
      if (data.answer) {
        setGeneratedAnswer(data.answer);
      } else {
        throw new Error('No answer received from API');
      }
    } catch (err: unknown) {
      console.error("Generation fetch error:", err);
      setError(err instanceof Error ? err.message : 'An unexpected error occurred.');
      setGeneratedAnswer(null);
    } finally {
      setIsGenerating(false);
    }
  };

  // We'll use the useAccordionItem hook inside the AccordionContent component
  // to detect when the accordion is opened

  return (
    <AccordionItem
      value={value}
      className="mb-4 bg-white dark:bg-gray-800 rounded-lg shadow-sm border border-gray-200 dark:border-gray-700 overflow-hidden"
    >
      <div className="flex items-center justify-between px-4">
        <AccordionTrigger className="py-4 text-gray-900 dark:text-white font-medium">
          {question.question_text || 'Question text not available'}
        </AccordionTrigger>

        <div className="flex items-center flex-shrink-0 ml-2" onClick={(e) => e.stopPropagation()}>
          {question.id && (
            <div className="mr-2">
              <BookmarkButton
                questionId={question.id}
                initialIsBookmarked={isBookmarked}
                onBookmarkChange={setIsBookmarked}
              />
            </div>
          )}
          <span className="text-xs text-gray-500 dark:text-gray-400 mr-2">Q{questionIndex + 1}</span>
        </div>
      </div>

      <AccordionContent className="px-4">
        <AnswerContent
          question={question}
          answerRef={answerRef}
          isGenerating={isGenerating}
          setIsGenerating={setIsGenerating}
          error={error}
          setError={setError}
          generatedAnswer={generatedAnswer}
          setGeneratedAnswer={setGeneratedAnswer}
          hasPredefinedAnswer={hasPredefinedAnswer}
          scrollProgress={scrollProgress}
          generateAnswer={generateAnswer}
        />
      </AccordionContent>
    </AccordionItem>
  );
}

interface AnswerContentProps {
  question: QuestionType;
  answerRef: React.RefObject<HTMLDivElement>;
  isGenerating: boolean;
  setIsGenerating: (value: boolean) => void;
  error: string | null;
  setError: (value: string | null) => void;
  generatedAnswer: string | null;
  setGeneratedAnswer: (value: string | null) => void;
  hasPredefinedAnswer: boolean;
  scrollProgress: number;
  generateAnswer: () => Promise<void>;
}

function AnswerContent({
  question,
  answerRef,
  isGenerating,
  setIsGenerating,
  error,
  setError,
  generatedAnswer,
  setGeneratedAnswer,
  hasPredefinedAnswer,
  scrollProgress,
  generateAnswer
}: AnswerContentProps) {
  // Use the accordion context to detect when the accordion is opened
  const { isOpen } = useAccordionItem();

  // Generate answer when the accordion is opened
  useEffect(() => {
    if (isOpen && !hasPredefinedAnswer && !generatedAnswer && !isGenerating) {
      generateAnswer();
    }
  }, [isOpen, hasPredefinedAnswer, generatedAnswer, isGenerating, generateAnswer]);

  return (
    <div className="mt-2 border-t border-gray-200 dark:border-gray-700 pt-4">
      <h5 className="text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Answer:</h5>
      <div
        ref={answerRef}
        className="text-gray-800 dark:text-gray-200 prose dark:prose-invert max-w-none max-h-[600px] overflow-y-auto pr-2 text-base"
      >
        {isGenerating ? (
          <div className="flex items-center space-x-2 text-gray-500">
            <div className="inline-block animate-spin rounded-full h-4 w-4 border-t-2 border-gray-500 border-r-2 border-gray-500"></div>
            <span>Generating answer...</span>
          </div>
        ) : error ? (
          <p className="text-red-600 dark:text-red-400">Error: {error}</p>
        ) : generatedAnswer ? (
          <ReactMarkdown>{generatedAnswer}</ReactMarkdown>
        ) : hasPredefinedAnswer ? (
          <ReactMarkdown>{question.answer_text || ''}</ReactMarkdown>
        ) : (
          <p className="italic text-gray-500">No pre-defined answer. Answer generation uses your preferred Groq model and API key (set in Account). You can customize the answer format via the prompt template in your Account Preferences.</p>
        )}
      </div>

      {/* Progress indicator */}
      {(generatedAnswer || hasPredefinedAnswer) && (
        <div className="mt-4 w-full bg-gray-200 dark:bg-gray-700 rounded-full h-1.5">
          <div
            className="bg-green-500 h-1.5 rounded-full transition-all duration-300"
            style={{ width: `${scrollProgress}%` }}
          ></div>
        </div>
      )}
    </div>
  );
}
