'use client';

import { useState, useEffect, useRef } from 'react';
import ReactMarkdown from 'react-markdown';
import { BookmarkButton } from './BookmarkButton';
import { isQuestionBookmarked, isQuestionCompleted, markQuestionAsCompleted } from '@/app/utils/progress';
import { Accordion, AccordionItem, AccordionTrigger, AccordionContent, useAccordionItem } from "@/app/components/ui/radix-accordion";

// Define QuestionType locally based on usage in topics/page.tsx
type QuestionType = {
  id: number;
  question_text: string;
  answer_text?: string | null;
  keywords?: string[] | string | null;
  difficulty?: string | null;
  category_id?: number | null;
};

interface AccordionQuestionAnswerProps {
  questions: QuestionType[];
}

export function AccordionQuestionAnswer({ questions }: AccordionQuestionAnswerProps) {
  return (
    <Accordion
      type="single"
      collapsible
      className="w-full"
    >
      {questions.map((question, index) => (
        <QuestionItem
          key={question.id || index}
          question={question}
          questionIndex={index}
          value={`question-${question.id || index}`}
        />
      ))}
    </Accordion>
  );
}

interface QuestionItemProps {
  question: QuestionType;
  questionIndex: number;
  value: string;
}

function QuestionItem({ question, questionIndex, value }: QuestionItemProps) {
  const [isGenerating, setIsGenerating] = useState(false);
  const [generatedAnswer, setGeneratedAnswer] = useState<string | null>(null);
  const [error, setError] = useState<string | null>(null);
  const [isViewed, setIsViewed] = useState(false);
  const [isBookmarked, setIsBookmarked] = useState(false);
  const [isCompleted, setIsCompleted] = useState(false);
  const [scrollProgress, setScrollProgress] = useState(0);
  const answerRef = useRef<HTMLDivElement>(null);
  const scrollTimeoutRef = useRef<NodeJS.Timeout | null>(null);

  // Determine if the existing answer is actual content or placeholder
  const hasPredefinedAnswer = question.answer_text &&
                             !question.answer_text.toLowerCase().includes('generated by ai');

  // Check completion status of questions when they load
  useEffect(() => {
    if (question.id) {
      // Check bookmark status
      isQuestionBookmarked(question.id)
        .then(bookmarked => setIsBookmarked(bookmarked))
        .catch(err => console.error('Failed to check bookmark status:', err));

      // First check localStorage for completed questions
      try {
        const localStorageCompletedQuestions = JSON.parse(localStorage.getItem('completedQuestions') || '[]');
        const sessionStorageCompletedQuestions = JSON.parse(sessionStorage.getItem('completedQuestions') || '[]');
        
        if (localStorageCompletedQuestions.includes(question.id) || 
            sessionStorageCompletedQuestions.includes(question.id)) {
          console.log(`Question ${question.id} found in client storage as completed`);
          setIsCompleted(true);
          return; // Skip API call if already found in storage
        }
      } catch (err) {
        console.error('Error checking client storage:', err);
      }

      // Check completion status via API if not found in storage
      isQuestionCompleted(question.id)
        .then(completed => {
          console.log(`Question ${question.id} completion status:`, completed);
          setIsCompleted(completed);
          
          // If completed, store in localStorage for future reference
          if (completed) {
            try {
              const completedQuestions = JSON.parse(localStorage.getItem('completedQuestions') || '[]');
              if (!completedQuestions.includes(question.id)) {
                completedQuestions.push(question.id);
                localStorage.setItem('completedQuestions', JSON.stringify(completedQuestions));
              }
            } catch (storageError) {
              console.error('Error updating localStorage:', storageError);
            }
          }
        })
        .catch(err => console.error('Failed to check completion status:', err));
    }
  }, [question.id]);

  // Track scroll progress in the answer content
  useEffect(() => {
    const answerElement = answerRef.current;
    if (!answerElement) return;

    const handleScroll = () => {
      if (scrollTimeoutRef.current) {
        clearTimeout(scrollTimeoutRef.current);
      }

      scrollTimeoutRef.current = setTimeout(() => {
        const { scrollTop, scrollHeight, clientHeight } = answerElement;
        const scrolled = (scrollTop / (scrollHeight - clientHeight)) * 100;
        setScrollProgress(Math.min(Math.max(scrolled, 0), 100));
        
        console.log(`Question ${question.id} scroll progress: ${scrolled.toFixed(1)}%, isCompleted: ${isCompleted}`);

        // Mark as completed when scrolled more than 90%
        if (scrolled > 90 && !isCompleted && question.id) {
          console.log(`Scroll threshold reached for question ${question.id}, marking as completed`);
          
          // Mark as completed in the database
          markQuestionAsCompleted(question.id)
            .then((success) => {
              if (success) {
                setIsCompleted(true);
                console.log(`Question ${question.id} marked as completed in database`);
                
                // Update localStorage
                try {
                  const completedQuestions = JSON.parse(localStorage.getItem('completedQuestions') || '[]');
                  if (!completedQuestions.includes(question.id)) {
                    completedQuestions.push(question.id);
                    localStorage.setItem('completedQuestions', JSON.stringify(completedQuestions));
                    console.log(`Question ${question.id} added to localStorage completed list`);
                  }
                } catch (storageError) {
                  console.error('Error updating localStorage:', storageError);
                }

                // Dispatch an event to notify other components
                window.dispatchEvent(new CustomEvent('questionCompleted', {
                  detail: {
                    questionId: question.id,
                    categoryId: question.category_id,
                    status: 'completed',
                    timestamp: Date.now()
                  }
                }));
                console.log('Dispatched questionCompleted event with details:', {
                  questionId: question.id,
                  categoryId: question.category_id,
                  status: 'completed',
                  timestamp: Date.now()
                });
              } else {
                console.error(`Failed to mark question ${question.id} as completed`);
              }
            })
            .catch(err => console.error('Failed to mark question as completed:', err));
        }
      }, 100);
    };

    answerElement.addEventListener('scroll', handleScroll);
    return () => {
      if (scrollTimeoutRef.current) {
        clearTimeout(scrollTimeoutRef.current);
      }
      answerElement?.removeEventListener('scroll', handleScroll);
    };
  }, [question.id, isViewed, isCompleted]);

  // Fetch generated answer when expanded, if applicable
  const generateAnswer = async () => {
    if (hasPredefinedAnswer || generatedAnswer || isGenerating) return;

    setIsGenerating(true);
    setError(null);
    try {
      console.log(`Generating answer for question: ${question.id} - ${question.question_text}`);
      const response = await fetch('/api/generate-answer', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          questionText: question.question_text,
          questionId: question.id,
        }),
      });

      if (!response.ok) {
        throw new Error(`API error: ${response.status}`);
      }

      const data = await response.json();
      if (data.answer) {
        setGeneratedAnswer(data.answer);
      } else {
        throw new Error('No answer received from API');
      }
    } catch (err: unknown) {
      console.error("Generation fetch error:", err);
      setError(err instanceof Error ? err.message : 'An unexpected error occurred.');
      setGeneratedAnswer(null);
    } finally {
      setIsGenerating(false);
    }
  };

  // We'll use the useAccordionItem hook inside the AccordionContent component
  // to detect when the accordion is opened

  return (
    <AccordionItem
      value={value}
      className="mb-4 bg-white dark:bg-gray-800 rounded-lg shadow-sm border border-gray-200 dark:border-gray-700 overflow-hidden"
    >
      <div className="flex items-center justify-between px-4">
        <AccordionTrigger className="py-4 text-gray-900 dark:text-white font-medium">
          <div className="flex items-center">
            {isCompleted && (
              <div className="mr-2 text-green-600 dark:text-green-400 flex-shrink-0">
                <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                  <path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clipRule="evenodd" />
                </svg>
              </div>
            )}
            <span>{question.question_text || 'Question text not available'}</span>
          </div>
        </AccordionTrigger>

        <div className="flex items-center flex-shrink-0 ml-2" onClick={(e) => e.stopPropagation()}>
          {question.id && (
            <div className="mr-2">
              <BookmarkButton
                questionId={question.id}
                initialIsBookmarked={isBookmarked}
                onBookmarkChange={setIsBookmarked}
              />
            </div>
          )}
          <span className="text-xs text-gray-500 dark:text-gray-400 mr-2">Q{questionIndex + 1}</span>
        </div>
      </div>

      <AccordionContent className="px-4">
        <AnswerContent
          question={question}
          answerRef={answerRef}
          isGenerating={isGenerating}
          setIsGenerating={setIsGenerating}
          error={error}
          setError={setError}
          generatedAnswer={generatedAnswer}
          setGeneratedAnswer={setGeneratedAnswer}
          hasPredefinedAnswer={!!hasPredefinedAnswer}
          scrollProgress={scrollProgress}
          generateAnswer={generateAnswer}
        />
      </AccordionContent>
    </AccordionItem>
  );
}

interface AnswerContentProps {
  question: QuestionType;
  answerRef: React.RefObject<HTMLDivElement | null>;
  isGenerating: boolean;
  setIsGenerating: (value: boolean) => void;
  error: string | null;
  setError: (value: string | null) => void;
  generatedAnswer: string | null;
  setGeneratedAnswer: (value: string | null) => void;
  hasPredefinedAnswer: boolean;
  scrollProgress: number;
  generateAnswer: () => Promise<void>;
}

function AnswerContent({
  question,
  answerRef,
  isGenerating,
  setIsGenerating,
  error,
  setError,
  generatedAnswer,
  setGeneratedAnswer,
  hasPredefinedAnswer,
  scrollProgress,
  generateAnswer
}: AnswerContentProps) {
  // Use the accordion context to detect when the accordion is opened
  const { isOpen } = useAccordionItem();

  // Generate answer when the accordion is opened
  useEffect(() => {
    if (isOpen && !hasPredefinedAnswer && !generatedAnswer && !isGenerating) {
      generateAnswer();
    }
  }, [isOpen, hasPredefinedAnswer, generatedAnswer, isGenerating, generateAnswer]);

  return (
    <div className="mt-2 border-t border-gray-200 dark:border-gray-700 pt-4">
      <h5 className="text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Answer:</h5>
      <div
        ref={answerRef}
        className="text-gray-800 dark:text-gray-200 prose dark:prose-invert max-w-none h-[600px] overflow-y-auto pr-2 text-base"
      >
        {isGenerating ? (
          <div className="flex items-center space-x-2 text-gray-500">
            <div className="inline-block animate-spin rounded-full h-4 w-4 border-t-2 border-gray-500 border-r-2 border-gray-500"></div>
            <span>Generating answer...</span>
          </div>
        ) : error ? (
          <p className="text-red-600 dark:text-red-400">Error: {error}</p>
        ) : generatedAnswer ? (
          <ReactMarkdown>{generatedAnswer}</ReactMarkdown>
        ) : hasPredefinedAnswer ? (
          <ReactMarkdown>{question.answer_text || ''}</ReactMarkdown>
        ) : (
          <p className="italic text-gray-500">No pre-defined answer. Answer generation uses your preferred Groq model and API key (set in Account). You can customize the answer format via the prompt template in your Account Preferences.</p>
        )}
      </div>

      {/* Progress indicator */}
      {(generatedAnswer || hasPredefinedAnswer) && (
        <div className="mt-4 pt-2 border-t border-gray-200 dark:border-gray-700">
          <div className="flex items-center justify-between text-xs text-gray-500 dark:text-gray-400 mb-1">
            <span>Read progress</span>
            <span>{scrollProgress}%</span>
          </div>
          <div className="w-full bg-gray-200 dark:bg-gray-700 h-1 rounded-full overflow-hidden">
            <div
              className="bg-green-500 h-1 rounded-full transition-all duration-300 ease-in-out"
              style={{ width: `${scrollProgress}%` }}
            ></div>
          </div>
          {scrollProgress >= 90 && (
            <div className="mt-1 text-xs text-green-600 dark:text-green-400 flex items-center">
              <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4 mr-1" viewBox="0 0 20 20" fill="currentColor">
                <path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clipRule="evenodd" />
              </svg>
              Almost complete - continue reading to mark as done
            </div>
          )}
        </div>
      )}
    </div>
  );
}
