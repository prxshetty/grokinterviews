"use client";

import { useState, useEffect } from 'react';
import ReactMarkdown from 'react-markdown';
// Attempting import from common Supabase types location
// import { Tables } from '@/types/database.types'; 
// Removed ContentDisplay import as it's not suitable
// import ContentDisplay from './ContentDisplay'; 

// Define mapping from our topic IDs to numeric database IDs
const TOPIC_ID_MAP: Record<string, number> = {
  // Main Categories
  "ml": 1,
  "ai": 2,
  "webdev": 3,
  "system-design": 4,
  "dsa": 5,

  // ML Topics
  "ml-foundations": 1,
  "ml-core-concepts": 1,
  "ml-math-foundations": 2,
  "ml-data-preprocessing": 3,
  "ml-supervised": 5,
  "ml-regression": 6,
  "ml-classification": 7,
  "ml-unsupervised": 8,
  "ml-clustering": 9,
  "ml-dimensionality": 10,
  "ml-neural-networks": 11,
  "ml-nn-fundamentals": 11,
  "ml-nn-architectures": 11,
  "ml-cnn": 11,
  "ml-rnn": 11,
  "ml-transformers": 11,
  "ml-decision-trees": 12,
  "ml-naive-bayes": 13,
  "ml-ensemble": 14,

  "ml-model-evaluation": 15,
  "ml-validation": 15,
  "ml-metrics": 15,

  "ml-deep-learning": 16,
  "ml-transfer-learning": 16,
  "ml-gans": 16,

  "ml-nlp": 17,
  "ml-word-embeddings": 17,
  "ml-llm": 17,

  "ml-reinforcement": 5, // Map to supervised learning as fallback
  "ml-time-series": 18,
  "ml-practical": 20,

  // AI Topics (will map to related ML topics where applicable)
  "ai-foundations": 1,
  "ai-nlp": 17,
  "ai-cv": 16,
  "ai-rl": 5,
  "ai-ethics": 15,

  // Other topics will fall back to ML foundations if no specific mapping
};

// Define QuestionType locally based on usage in topics/page.tsx
// This ensures the component works even if the central types file is missing/incorrect
type QuestionType = {
  id: number; // Assuming id is always a number based on usage
  question_text: string;
  answer_text?: string | null;
  keywords?: string[] | string | null; // Allow for string or array
  difficulty?: string | null;
  category_id?: number | null;
  // Add any other fields passed from topics/page.tsx if needed
};

interface Question {
  question_id: number;
  title: string;
}

interface Content {
  content_id: number | string;
  content_type: string;
  content: string | null;
  media_url: string | null;
  caption: string | null;
  subtype: string | null;
  youtube_video_id?: string;
  display_order?: number;
}

interface QuestionWithAnswerProps {
  question: QuestionType;
  questionIndex: number;
}

export function QuestionWithAnswer({ question, questionIndex }: QuestionWithAnswerProps) {
  const [isExpanded, setIsExpanded] = useState(false);
  const [isGenerating, setIsGenerating] = useState(false);
  const [generatedAnswer, setGeneratedAnswer] = useState<string | null>(null);
  const [error, setError] = useState<string | null>(null);

  // Determine if the existing answer is actual content or placeholder
  const hasPredefinedAnswer = question.answer_text && 
                             !question.answer_text.toLowerCase().includes('generated by ai'); 

  const questionId = `q-${question.id || questionIndex}`;

  // Fetch generated answer when expanded, if applicable
  useEffect(() => {
    if (isExpanded && !hasPredefinedAnswer && !generatedAnswer && !isGenerating && !error) {
      const generateAnswer = async () => {
        setIsGenerating(true);
        setError(null);
        try {
          console.log(`Generating answer for question: ${question.id} - ${question.question_text}`); // Debug log
          const response = await fetch('/api/generate-answer', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({ 
              questionText: question.question_text,
            }),
          });

          const data = await response.json();
          console.log("API Response:", data); // Debug log

          if (!response.ok) {
            if (data.message) {
              setError(data.message); 
            } else {
              throw new Error(data.error || 'Failed to generate answer');
            }
            setGeneratedAnswer(null); 
          } else if (data.answer === null && data.message) { 
            setError(data.message);
            setGeneratedAnswer(null);
          } else {
            setGeneratedAnswer(data.answer || 'No answer content received.');
          }
        } catch (err: any) {
          console.error("Generation fetch error:", err);
          setError(err.message || 'An unexpected error occurred.');
          setGeneratedAnswer(null);
        } finally {
          setIsGenerating(false);
        }
      };

      generateAnswer();
    }
  }, [isExpanded, hasPredefinedAnswer, generatedAnswer, isGenerating, error, question.id, question.question_text]); 

  const toggleExpansion = () => {
    setIsExpanded(!isExpanded);
    if(isExpanded) { // Reset error when collapsing 
       setError(null); 
       // Decide if you want to clear the generated answer on collapse
       // setGeneratedAnswer(null); 
    }
  };
  
  // Helper to handle keywords potentially being a string
  const displayKeywords = (keywords: string[] | string | null | undefined): string => {
    if (!keywords) return '';
    if (Array.isArray(keywords)) return keywords.join(', ');
    return keywords; // Assume it's already a string
  };

  return (
    <div className="mb-4 p-4 bg-white dark:bg-gray-800 rounded-lg shadow-sm border border-gray-200 dark:border-gray-700">
      {/* Clickable Question Header */}
      <div 
        className="flex items-start justify-between mb-2 cursor-pointer" 
        onClick={toggleExpansion}
        role="button"
        aria-expanded={isExpanded}
        aria-controls={`answer-content-${questionId}`}
      >
        <h4 className="font-medium text-gray-900 dark:text-white pr-4">
          {question.question_text || 'Question text not available'}
        </h4>
        <div className="flex items-center flex-shrink-0">
          <span className="text-xs text-gray-500 dark:text-gray-400 mr-2">Q{questionIndex + 1}</span>
          <button
            className="text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200 focus:outline-none" 
            aria-hidden="true"
            tabIndex={-1}
          >
            <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 transform transition-transform" style={{ transform: isExpanded ? 'rotate(180deg)' : 'rotate(0deg)' }} viewBox="0 0 20 20" fill="currentColor">
              <path fillRule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clipRule="evenodd" />
            </svg>
          </button>
        </div>
      </div>

      {/* Difficulty and keywords */}
      <div className="mt-2 text-xs text-gray-500 dark:text-gray-400">
        <span className="inline-block bg-gray-200 dark:bg-gray-700 rounded px-2 py-1 mr-2">
          {question.difficulty || 'unspecified'} difficulty
        </span>
        {question.keywords && (
          <span className="inline-block">
            Keywords: {displayKeywords(question.keywords)}
          </span>
        )}
      </div>

      {/* Collapsible Answer Section */}
      {isExpanded && (
        <div id={`answer-content-${questionId}`} className="mt-4 pt-4 border-t border-gray-200 dark:border-gray-700">
          <h5 className="text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Answer:</h5>
          {/* Using prose for markdown styling */}
          <div className="text-gray-700 dark:text-gray-300 text-sm prose dark:prose-invert max-w-none">
            {isGenerating ? (
              <div className="flex items-center space-x-2 text-gray-500">
                 <div className="inline-block animate-spin rounded-full h-4 w-4 border-t-2 border-gray-500 border-r-2 border-gray-500"></div>
                 <span>Generating answer...</span>
              </div>
            ) : error ? (
              <p className="text-red-600 dark:text-red-400">Error: {error}</p>
            ) : generatedAnswer ? (
               <ReactMarkdown>{generatedAnswer}</ReactMarkdown>
            ) : hasPredefinedAnswer ? (
               <ReactMarkdown>{question.answer_text || ''}</ReactMarkdown>
            ) : (
              // Updated placeholder message
              <p className="italic text-gray-500">No pre-defined answer. Answer generation requires selecting Groq and providing an API key in your account settings.</p> 
            )}
          </div>
        </div>
      )}
    </div>
  );
}

// Make sure to export it if index.ts is used
// export { QuestionWithAnswer }; 