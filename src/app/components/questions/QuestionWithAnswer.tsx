"use client";

import { useState, useEffect, useRef, memo, useMemo, useCallback, Suspense } from 'react';
import { isQuestionBookmarked, isQuestionCompleted, markQuestionAsCompleted, markQuestionAsViewed } from '@/app/utils/progress';
import { createClientComponentClient } from '@supabase/auth-helpers-nextjs';
import React from 'react';

// Import the new components
import { QuestionHeader } from './QuestionHeader';
import { AnswerDisplay } from './AnswerDisplay';

// Lazy load ResourceList component for better performance
const ResourceList = React.lazy(() => 
  import('./ResourceList').then(module => ({ default: module.ResourceList }))
);

// ResourceList loading fallback component
function ResourceListSkeleton() {
  return (
    <div className="mt-2 mb-4">
      <div className="h-4 bg-gray-200 dark:bg-gray-700 rounded w-32 mb-3 animate-pulse"></div>
      <div className="grid gap-x-6 gap-y-4" style={{ gridTemplateColumns: 'repeat(2, minmax(0, 1fr))' }}>
        {[1, 2].map((i) => (
          <div key={i}>
            <div className="h-4 bg-gray-200 dark:bg-gray-700 rounded w-16 mb-1.5 animate-pulse"></div>
            <div className="space-y-1">
              {[1, 2].map((j) => (
                <div key={j} className="flex items-center space-x-2">
                  <div className="w-4 h-4 bg-gray-200 dark:bg-gray-700 rounded animate-pulse flex-shrink-0"></div>
                  <div className="h-3 bg-gray-200 dark:bg-gray-700 rounded flex-grow animate-pulse"></div>
                </div>
              ))}
            </div>
          </div>
        ))}
      </div>
    </div>
  );
}

// Define QuestionType locally based on usage in topics/page.tsx
type QuestionType = {
  id: number;
  question_text: string;
  answer_text?: string | null;
  keywords?: string[] | string | null;
  difficulty?: string | null;
  category_id?: number | null;
  topic_id?: number | null;
  categories?: { 
    id: number;
    name: string;
    topic_id: number;
  };
};

interface QuestionWithAnswerProps {
  question: QuestionType;
  questionIndex: number;
  isHighlighted?: boolean;
  topicId?: number;
}

// Renaming original component and preparing for memoization
function QuestionWithAnswerComponent({ question, questionIndex, isHighlighted = false, topicId }: QuestionWithAnswerProps) {
  // Initialize Supabase client
  const supabase = createClientComponentClient();

  const [isExpanded, setIsExpanded] = useState(false);
  const [isGenerating, setIsGenerating] = useState(false);
  const [generatedAnswer, setGeneratedAnswer] = useState<string | null>(null);
  const [error, setError] = useState<string | null>(null);
  const [isViewed, setIsViewed] = useState(false);
  const [isBookmarked, setIsBookmarked] = useState(false);
  const [isCompleted, setIsCompleted] = useState(false);
  const [scrollProgress, setScrollProgress] = useState(0);
  const answerRef = useRef<HTMLDivElement | null>(null);
  const scrollTimeoutRef = useRef<NodeJS.Timeout | null>(null);

  // Memoize expensive calculations
  const hasPredefinedAnswer = useMemo(() => {
    return question.answer_text &&
           !question.answer_text.toLowerCase().includes('generated by ai');
  }, [question.answer_text]);

  const questionId = question.id;
  const categoryId = question.categories?.id ?? question.category_id;

  // Memoize the displayed keywords string
  const displayedKeywords = useMemo(() => {
    if (!question.keywords) return '';
    if (Array.isArray(question.keywords)) return question.keywords.join(', ');
    return question.keywords;
  }, [question.keywords]);

  useEffect(() => {
    if (question.id) {
      console.log(`Checking status for question ${question.id}`);

      try {
        const localStorageCompletedQuestions = JSON.parse(localStorage.getItem('completedQuestions') || '[]');
        const sessionStorageCompletedQuestions = JSON.parse(sessionStorage.getItem('completedQuestions') || '[]');
        if (localStorageCompletedQuestions.includes(question.id) || 
            sessionStorageCompletedQuestions.includes(question.id)) {
          console.log(`Question ${question.id} found in client storage as completed`);
          setIsCompleted(true);
        }
      } catch (err) {
        console.error('Error checking client storage:', err);
      }

      isQuestionBookmarked(question.id)
        .then(bookmarked => {
          setIsBookmarked(bookmarked);
        })
        .catch(err => console.error('Failed to check bookmark status:', err));
      
      if (!isCompleted) {
        fetch(`/api/user/progress/status?questionId=${question.id}`, { headers: { 'Cache-Control': 'no-store' } })
        .then(response => response.json())
        .then(data => {
          if (data.status === 'completed') {
            setIsCompleted(true);
            try {
              const completedQuestions = JSON.parse(localStorage.getItem('completedQuestions') || '[]');
              if (!completedQuestions.includes(question.id)) {
                completedQuestions.push(question.id);
                localStorage.setItem('completedQuestions', JSON.stringify(completedQuestions));
              }
            } catch (err) {
              console.error('Error updating localStorage after API check:', err);
            }
          }
        })
        .catch(err => {
          console.error(`Error checking status for question ${question.id}:`, err);
        });
      }
    }
  }, [question.id, isCompleted]);

  useEffect(() => {
    if (isExpanded && !isViewed && question.id) {
      markQuestionAsViewed(question.id, question.topic_id, question.category_id)
        .then((success) => {
          if (success) {
            setIsViewed(true);
            console.log(`Question ${question.id} marked as viewed successfully`);
          } else {
            console.error(`Failed to mark question ${question.id} as viewed`);
          }
        })
        .catch(err => console.error('Failed to mark question as viewed:', err));
    }
  }, [isExpanded, isViewed, question.id, question.topic_id, question.category_id]);

  useEffect(() => {
    const answerIsReady = isExpanded && 
                         ((hasPredefinedAnswer && question.answer_text) || 
                          (!hasPredefinedAnswer && generatedAnswer && !isGenerating));

    if (!answerIsReady || !answerRef.current || !question.id) return;

    const answerElement = answerRef.current;
    setScrollProgress(0);

    const calculateScrollProgress = () => {
      if (!answerElement) return;
      const totalHeight = answerElement.scrollHeight - answerElement.clientHeight;
      if (totalHeight <= 0) {
        setScrollProgress(10);
        return;
      }
      const scrollPosition = answerElement.scrollTop;
      const percentage = Math.min(Math.round((scrollPosition / totalHeight) * 100), 100);
      setScrollProgress(percentage);

      console.log(`Question ${question.id} scroll progress: ${percentage}%, isCompleted: ${isCompleted}`);

      if (percentage >= 90 && !isCompleted && question.id) {
        console.log(`Scroll progress reached ${percentage}%, marking question ${question.id} as completed`);
        markQuestionAsCompleted(question.id, topicId || 0, categoryId || 0)
          .then((success) => {
            if (success) {
              setIsCompleted(true);
              console.log(`Question ${question.id} marked as completed in database`);
              try {
                const completedQuestions = JSON.parse(localStorage.getItem('completedQuestions') || '[]');
                if (!completedQuestions.includes(question.id)) {
                  completedQuestions.push(question.id);
                  localStorage.setItem('completedQuestions', JSON.stringify(completedQuestions));
                  console.log(`Question ${question.id} added to localStorage completed list`);
                }
              } catch (storageError) { console.error('Error updating localStorage:', storageError); }
              try {
                const completedSessionQuestions = JSON.parse(sessionStorage.getItem('completedQuestions') || '[]');
                 if (!completedSessionQuestions.some((q: any) => q.questionId === question.id)) {
                    completedSessionQuestions.push({
                      questionId: question.id,
                      topicId: topicId,
                      categoryId: categoryId,
                    });
                    sessionStorage.setItem('completedQuestions', JSON.stringify(completedSessionQuestions));
                    console.log(`Added question ${question.id} to completedQuestions in sessionStorage`);
                 }
              } catch (storageError) { console.error('Error storing completed question in session storage:', storageError); }
              try {
                window.dispatchEvent(new CustomEvent('questionCompleted', { detail: { questionId: question.id, topicId: topicId, categoryId: categoryId, status: 'completed', timestamp: Date.now() } }));
                console.log('Dispatched questionCompleted event');
              } catch (eventError) { console.error('Error dispatching completion event:', eventError); }
            } else { console.error(`Failed to mark question ${question.id} as completed`); }
          })
          .catch(err => { console.error('Failed to mark question as completed:', err); });
      }
    };

    const handleScroll = () => {
      if (scrollTimeoutRef.current) clearTimeout(scrollTimeoutRef.current);
      scrollTimeoutRef.current = setTimeout(calculateScrollProgress, 100);
    };

    const initialTimer = setTimeout(calculateScrollProgress, 500);
    answerElement.addEventListener('scroll', handleScroll);

    return () => {
      if (scrollTimeoutRef.current) clearTimeout(scrollTimeoutRef.current);
      clearTimeout(initialTimer);
      if (answerElement) answerElement.removeEventListener('scroll', handleScroll);
    };
  }, [isExpanded, question.id, topicId, categoryId, generatedAnswer, hasPredefinedAnswer, isGenerating, question.answer_text, isCompleted]);

  useEffect(() => {
    if (isExpanded && !hasPredefinedAnswer && !generatedAnswer && !isGenerating && !error) {
      const generateAnswer = async () => {
        setIsGenerating(true);
        setError(null);
        try {
          console.log(`Generating answer for question: ${question.id} - ${question.question_text}`);
          const response = await fetch('/api/generate-answer', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ questionText: question.question_text, questionId: question.id }),
          });
          const data = await response.json();
          console.log("API Response:", data);
          if (!response.ok) {
            setError(data.message || data.error || 'Failed to generate answer');
            setGeneratedAnswer(null);
          } else if (data.answer === null && data.message) {
            setError(data.message);
            setGeneratedAnswer(null);
          } else {
            setGeneratedAnswer(data.answer || 'No answer content received.');
          }
        } catch (err: unknown) { 
          console.error("Generation fetch error:", err);
          setError(err instanceof Error ? err.message : 'An unexpected error occurred.');
          setGeneratedAnswer(null);
        } finally { setIsGenerating(false); }
      };
      generateAnswer();
    }
  }, [isExpanded, hasPredefinedAnswer, generatedAnswer, isGenerating, error, question.id, question.question_text]);

  const toggleExpansion = () => {
    setIsExpanded(!isExpanded);
    if (isExpanded) {
      setError(null);
    }
  };

  const handleBookmarkChange = useCallback((newBookmarkStatus: boolean) => {
    setIsBookmarked(newBookmarkStatus);
  }, []);

  const displayKeywords = (keywords: string[] | string | null | undefined): string => {
    if (!keywords) return '';
    if (Array.isArray(keywords)) return keywords.join(', ');
    return keywords; 
  };

  const handleSetAnswerRef = useCallback((el: HTMLDivElement | null) => {
    answerRef.current = el;
  }, []);

  console.log(`Rendering QuestionWithAnswer for question ${question.id}, isCompleted=${isCompleted}`);

  return (
    <div 
      id={`question-${question.id}`}
      className={`mb-4 p-4 rounded-lg shadow-sm border transition-all duration-300 ${
        isHighlighted 
          ? 'bg-yellow-50 dark:bg-yellow-900/20 border-yellow-400 dark:border-yellow-600 ring-2 ring-yellow-400/50' 
          : 'bg-white dark:bg-gray-800 border-gray-200 dark:border-gray-700'
      }`}
    >
      <QuestionHeader
        questionId={questionId}
        topicId={question.categories?.topic_id ?? topicId ?? question.topic_id ?? null}
        categoryId={question.category_id ?? null}
        questionText={question.question_text}
        questionIndex={questionIndex}
        isCompleted={isCompleted}
        isBookmarked={isBookmarked}
        isExpanded={isExpanded}
        onToggleExpansion={toggleExpansion}
        onBookmarkChange={handleBookmarkChange} 
      />

      <div className="mt-2 text-xs text-gray-500 dark:text-gray-400">
        <span className="inline-block bg-gray-200 dark:bg-gray-700 rounded px-2 py-1 mr-2">
          {question.difficulty || 'unspecified'} difficulty
        </span>
        {question.keywords && (
          <span className="inline-block">
            Keywords: {displayedKeywords}
          </span>
        )}
      </div>

      {isExpanded && (
        <div id={`answer-content-q-${questionId}`} className="mt-4">
          {/* Display additional resources first */}
          <React.Suspense fallback={<ResourceListSkeleton />}>
            <ResourceList questionId={questionId} />
          </React.Suspense>
          
          <AnswerDisplay
            answerText={(hasPredefinedAnswer ? question.answer_text : generatedAnswer) ?? null}
            isLoading={isGenerating}
            error={error}
            scrollProgress={scrollProgress}
            isCompleted={isCompleted}
            setAnswerRef={handleSetAnswerRef}
          />
        </div>
      )}
    </div>
  );
}

// Exporting the memoized component
export const QuestionWithAnswer = memo(QuestionWithAnswerComponent);