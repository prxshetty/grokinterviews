"use client";

import { useState, useEffect, useRef } from 'react';
import ReactMarkdown from 'react-markdown';
import { BookmarkButton } from './BookmarkButton';
import { isQuestionBookmarked, isQuestionCompleted, markQuestionAsCompleted } from '@/app/utils/progress';
import { createClientComponentClient } from '@supabase/auth-helpers-nextjs';

// Define QuestionType locally based on usage in topics/page.tsx
type QuestionType = {
  id: number;
  question_text: string;
  answer_text?: string | null;
  keywords?: string[] | string | null;
  difficulty?: string | null;
  category_id?: number | null;
  topic_id?: number | null;
};

interface QuestionWithAnswerProps {
  question: QuestionType;
  questionIndex: number;
}

export function QuestionWithAnswer({ question, questionIndex }: QuestionWithAnswerProps) {
  // Initialize Supabase client
  const supabase = createClientComponentClient();

  const [isExpanded, setIsExpanded] = useState(false);
  const [isGenerating, setIsGenerating] = useState(false);
  const [generatedAnswer, setGeneratedAnswer] = useState<string | null>(null);
  const [error, setError] = useState<string | null>(null);
  const [isViewed, setIsViewed] = useState(false);
  const [isBookmarked, setIsBookmarked] = useState(false);
  const [isCompleted, setIsCompleted] = useState(false);
  const [scrollProgress, setScrollProgress] = useState(0);
  const answerRef = useRef<HTMLDivElement>(null);
  const scrollTimeoutRef = useRef<NodeJS.Timeout | null>(null);

  // Determine if the existing answer is actual content or placeholder
  const hasPredefinedAnswer = question.answer_text &&
                             !question.answer_text.toLowerCase().includes('generated by ai');

  const questionId = `q-${question.id || questionIndex}`;

  // Check if question is bookmarked and completed when component mounts
  useEffect(() => {
    if (question.id) {
      console.log(`Checking status for question ${question.id}`);

      // First check localStorage for completed questions to avoid unnecessary API calls
      try {
        // Check both localStorage (persistent) and sessionStorage (session only)
        const localStorageCompletedQuestions = JSON.parse(localStorage.getItem('completedQuestions') || '[]');
        const sessionStorageCompletedQuestions = JSON.parse(sessionStorage.getItem('completedQuestions') || '[]');
        
        // If the question is marked as completed in either storage, set it as completed
        if (localStorageCompletedQuestions.includes(question.id) || 
            sessionStorageCompletedQuestions.includes(question.id)) {
          console.log(`Question ${question.id} found in client storage as completed`);
          setIsCompleted(true);
          // Still check bookmark status, but skip API call for completion status
        }
      } catch (err) {
        console.error('Error checking client storage:', err);
      }

      // Check bookmark status
      isQuestionBookmarked(question.id)
        .then(bookmarked => {
          setIsBookmarked(bookmarked);
        })
        .catch(err => console.error('Failed to check bookmark status:', err));
      
      // If not found in local storage, check via API (do this once)
      if (!isCompleted) {
        // Single API call to check status via the status endpoint
        fetch(`/api/user/progress/status?questionId=${question.id}`, {
          headers: { 'Cache-Control': 'no-store' }
        })
        .then(response => response.json())
        .then(data => {
          if (data.status === 'completed') {
            setIsCompleted(true);
            // Update localStorage
            try {
              const completedQuestions = JSON.parse(localStorage.getItem('completedQuestions') || '[]');
              if (!completedQuestions.includes(question.id)) {
                completedQuestions.push(question.id);
                localStorage.setItem('completedQuestions', JSON.stringify(completedQuestions));
              }
            } catch (err) {
              console.error('Error updating localStorage after API check:', err);
            }
          }
        })
        .catch(err => {
          console.error(`Error checking status for question ${question.id}:`, err);
        });
      }
    }
  }, [question.id, isCompleted]);

  // Mark question as viewed when expanded
  useEffect(() => {
    if (isExpanded && !isViewed && question.id) {
      // Update user progress to mark as viewed
      fetch('/api/user/progress', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          questionId: question.id,
          status: 'viewed',
        }),
      })
      .then(() => setIsViewed(true))
      .catch(err => console.error('Failed to mark question as viewed:', err));
    }
  }, [isExpanded, isViewed, question.id]);

  // Set up scroll tracking for progress
  useEffect(() => {
    // Only start tracking after the answer is fully loaded
    const answerIsReady = isExpanded &&
                         ((hasPredefinedAnswer && question.answer_text) ||
                          (!hasPredefinedAnswer && generatedAnswer && !isGenerating));

    if (!answerIsReady || !answerRef.current || !question.id) return;

    const answerElement = answerRef.current;

    // Reset progress when a new answer is loaded
    setScrollProgress(0);

    // Function to calculate scroll progress
    const calculateScrollProgress = () => {
      if (!answerElement) return;

      const totalHeight = answerElement.scrollHeight - answerElement.clientHeight;
      if (totalHeight <= 0) {
        // If there's no scroll possible, don't mark as complete immediately
        // Only set a small progress to show the bar has started
        setScrollProgress(10);
        return;
      }

      const scrollPosition = answerElement.scrollTop;
      const percentage = Math.min(Math.round((scrollPosition / totalHeight) * 100), 100);
      setScrollProgress(percentage);

      // Log scroll progress for debugging
      console.log(`Question ${question.id} scroll progress: ${percentage}%, isCompleted: ${isCompleted}`);

      // If user has scrolled to the bottom (or near bottom), mark as completed
      if (percentage >= 90 && !isCompleted && question.id) {
        console.log(`Scroll progress reached ${percentage}%, marking question ${question.id} as completed`);

        // Mark as completed in the database
        markQuestionAsCompleted(question.id, question.topic_id || 0, question.category_id || 0)
          .then((success) => {
            if (success) {
              setIsCompleted(true);
              console.log(`Question ${question.id} marked as completed in database`);

              // Update localStorage to persist the completion status
              try {
                const completedQuestions = JSON.parse(localStorage.getItem('completedQuestions') || '[]');
                if (!completedQuestions.includes(question.id)) {
                  completedQuestions.push(question.id);
                  localStorage.setItem('completedQuestions', JSON.stringify(completedQuestions));
                  console.log(`Question ${question.id} added to localStorage completed list`);
                }
              } catch (storageError) {
                console.error('Error updating localStorage:', storageError);
              }

              // Dispatch an event to notify other components
              try {
                window.dispatchEvent(new CustomEvent('questionCompleted', {
                  detail: {
                    questionId: question.id,
                    categoryId: question.category_id,
                    status: 'completed',
                    timestamp: Date.now()
                  }
                }));
                console.log('Dispatched questionCompleted event with details:', {
                  questionId: question.id,
                  categoryId: question.category_id,
                  status: 'completed',
                  timestamp: Date.now()
                });
              } catch (eventError) {
                console.error('Error dispatching completion event:', eventError);
              }

              // Also directly update the progress via API
              try {
                // Get the topic_id (subtopic) from the URL or use a default
                let subtopicId = new URLSearchParams(window.location.search).get('subtopicId');
                if (!subtopicId && question.topic_id) {
                  subtopicId = question.topic_id.toString();
                }

                // Wait a bit before refreshing progress to let the server-side updates complete
                setTimeout(async () => {
                  try {
                    // Only do a single optimized fetch for the current subtopic's progress
                    if (subtopicId) {
                      console.log(`Refreshing progress for subtopic ${subtopicId} (delayed refresh)`);
                      const subtopicResponse = await fetch(`/api/user/progress/subtopic-progress?subtopicId=${subtopicId}`, {
                        method: 'GET',
                        headers: {
                          'Cache-Control': 'no-store',
                        },
                      });
                      
                      if (subtopicResponse.ok) {
                        const subtopicData = await subtopicResponse.json();
                        console.log(`Updated subtopic ${subtopicId} progress:`, subtopicData);
                        
                        // Dispatch an event that other components can listen for
                        window.dispatchEvent(new CustomEvent('subtopicProgressUpdated', {
                          detail: {
                            subtopicId: parseInt(subtopicId),
                            progress: subtopicData,
                            timestamp: Date.now()
                          }
                        }));
                      }
                    }
                  } catch (err) {
                    console.error('Error refreshing progress after completion:', err);
                  }
                }, 1000); // Delay to allow server-side processing
              } catch (fetchError) {
                console.error('Error setting up progress refresh:', fetchError);
              }

              // Store in sessionStorage that this question has been completed
              try {
                const completedQuestions = JSON.parse(sessionStorage.getItem('completedQuestions') || '[]');
                if (!completedQuestions.includes(question.id)) {
                  completedQuestions.push(question.id);
                  sessionStorage.setItem('completedQuestions', JSON.stringify(completedQuestions));
                  console.log(`Added question ${question.id} to completedQuestions in sessionStorage`);
                }
              } catch (storageError) {
                console.error('Error storing completed question:', storageError);
              }
            } else {
              console.error(`Failed to mark question ${question.id} as completed`);
            }
          })
          .catch(err => {
            console.error('Failed to mark question as completed:', err);
          });
      }
    };

    // Add scroll event listener with debounce
    const handleScroll = () => {
      if (scrollTimeoutRef.current) {
        clearTimeout(scrollTimeoutRef.current);
      }

      scrollTimeoutRef.current = setTimeout(() => {
        calculateScrollProgress();
      }, 100); // Debounce for performance
    };

    // Wait a short time before initial calculation to ensure content is fully rendered
    const initialTimer = setTimeout(() => {
      calculateScrollProgress();
    }, 500);

    // Add event listener
    answerElement.addEventListener('scroll', handleScroll);

    return () => {
      // Clean up
      if (scrollTimeoutRef.current) {
        clearTimeout(scrollTimeoutRef.current);
      }
      clearTimeout(initialTimer);
      answerElement.removeEventListener('scroll', handleScroll);
    };
  }, [isExpanded, question.id, generatedAnswer, hasPredefinedAnswer, isGenerating, question.answer_text, isCompleted]);

  // Fetch generated answer when expanded, if applicable
  useEffect(() => {
    if (isExpanded && !hasPredefinedAnswer && !generatedAnswer && !isGenerating && !error) {
      const generateAnswer = async () => {
        setIsGenerating(true);
        setError(null);
        try {
          console.log(`Generating answer for question: ${question.id} - ${question.question_text}`);
          const response = await fetch('/api/generate-answer', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({
              questionText: question.question_text,
              questionId: question.id,
            }),
          });

          try {
            const data = await response.json();
            console.log("API Response:", data);

            if (!response.ok) {
              if (data.message) {
                setError(data.message);
              } else if (data.error) {
                setError(data.error);
              } else {
                setError('Failed to generate answer');
              }
              setGeneratedAnswer(null);
            } else if (data.answer === null && data.message) {
              setError(data.message);
              setGeneratedAnswer(null);
            } else {
              setGeneratedAnswer(data.answer || 'No answer content received.');
            }
          } catch (jsonError) {
            console.error('Error parsing JSON response:', jsonError);
            setError('Error processing server response');
            setGeneratedAnswer(null);
          }
        } catch (err: unknown) {
          console.error("Generation fetch error:", err);
          setError(err instanceof Error ? err.message : 'An unexpected error occurred.');
          setGeneratedAnswer(null);
        } finally {
          setIsGenerating(false);
        }
      };

      generateAnswer();
    }
  }, [isExpanded, hasPredefinedAnswer, generatedAnswer, isGenerating, error, question.id, question.question_text]);

  const toggleExpansion = () => {
    setIsExpanded(!isExpanded);
    if (isExpanded) {
      setError(null);
    }
  };

  // Helper to handle keywords potentially being a string
  const displayKeywords = (keywords: string[] | string | null | undefined): string => {
    if (!keywords) return '';
    if (Array.isArray(keywords)) return keywords.join(', ');
    return keywords; // Assume it's already a string
  };

  // Debug log for rendering
  console.log(`Rendering QuestionWithAnswer for question ${question.id}, isCompleted=${isCompleted}`);

  // Define refreshDomainProgress function here so it's accessible in the scope needed by the effect
  const refreshDomainProgress = async (domain: any, sectionName: any) => {
    console.log(`Refreshing progress for subtopics in domain ${domain}${sectionName ? ` for section ${sectionName}` : ''}`);
    try {
      const domainFetchUrl = `/api/user/progress/domain-subtopics?domain=${domain}${sectionName ? `&section=${encodeURIComponent(sectionName)}` : ''}&_t=${Date.now()}`;
      const response = await fetch(domainFetchUrl, {
        method: 'GET',
        headers: {
          'Cache-Control': 'no-cache',
        },
      });
      if (!response.ok) {
        console.error(`Failed to refresh domain subtopics progress: ${response.status}`);
      } else {
        const data = await response.json();
        console.log(`Received progress data for domain ${domain}${sectionName ? ` and section ${sectionName}` : ''}`);
        if (data.subtopics && typeof data.subtopics === 'object') {
          console.log(`Found ${Object.keys(data.subtopics).length} subtopics with progress data`);
          // Dispatch an event
          window.dispatchEvent(new CustomEvent('domainSubtopicsProgressUpdated', {
            detail: {
              domain,
              section: sectionName,
              subtopics: data.subtopics,
              timestamp: Date.now(),
              questionInfo: {
                categoryId: question.category_id,
                sectionName: sectionName
              }
            }
          }));
        } else {
          console.log('No subtopics progress data found in API response for domain/section');
        }
      }
    } catch (err) { // Explicitly type err if needed: catch (err: any)
      console.error('Error refreshing domain subtopics progress:', err);
    }
  };

  return (
    <div className="mb-4 p-4 bg-white dark:bg-gray-800 rounded-lg shadow-sm border border-gray-200 dark:border-gray-700">
      {/* Clickable Question Header */}
      <div
        className="flex items-start justify-between mb-2 cursor-pointer"
        onClick={toggleExpansion}
        role="button"
        aria-expanded={isExpanded}
        aria-controls={`answer-content-${questionId}`}
      >
        <div className="flex items-center">
          {isCompleted ? (
            <div className="mr-2 text-green-600 dark:text-green-400 flex-shrink-0">
              <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                <path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clipRule="evenodd" />
              </svg>
            </div>
          ) : (
            <div className="mr-2 w-5"></div>
          )}
          <h4 className="font-medium text-gray-900 dark:text-white pr-4">
            {question.question_text || 'Question text not available'}
          </h4>
        </div>
        <div className="flex items-center flex-shrink-0">
          {question.id && (
            <div className="mr-2" onClick={(e) => e.stopPropagation()}>
              <BookmarkButton
                questionId={question.id}
                initialIsBookmarked={isBookmarked}
                onBookmarkChange={setIsBookmarked}
              />
            </div>
          )}
          <span className="text-xs text-gray-500 dark:text-gray-400 mr-2">Q{questionIndex + 1}</span>
          <button
            className="text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200 focus:outline-none"
            aria-hidden="true"
            tabIndex={-1}
          >
            <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 transform transition-transform" style={{ transform: isExpanded ? 'rotate(180deg)' : 'rotate(0deg)' }} viewBox="0 0 20 20" fill="currentColor">
              <path fillRule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clipRule="evenodd" />
            </svg>
          </button>
        </div>
      </div>

      {/* Difficulty and keywords */}
      <div className="mt-2 text-xs text-gray-500 dark:text-gray-400">
        <span className="inline-block bg-gray-200 dark:bg-gray-700 rounded px-2 py-1 mr-2">
          {question.difficulty || 'unspecified'} difficulty
        </span>
        {question.keywords && (
          <span className="inline-block">
            Keywords: {displayKeywords(question.keywords)}
          </span>
        )}
      </div>

      {/* Collapsible Answer Section */}
      {isExpanded && (
        <div id={`answer-content-${questionId}`} className="mt-4 pt-4 border-t border-gray-200 dark:border-gray-700">
          <h5 className="text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Answer:</h5>
          <div
            ref={answerRef}
            className="text-gray-800 dark:text-gray-200 prose dark:prose-invert max-w-none h-[600px] overflow-y-auto pr-2 text-base"
          >
            {isGenerating ? (
              <div className="flex items-center space-x-2 text-gray-500">
                 <div className="inline-block animate-spin rounded-full h-4 w-4 border-t-2 border-gray-500 border-r-2 border-gray-500"></div>
                 <span>Generating answer...</span>
              </div>
            ) : error ? (
              <p className="text-red-600 dark:text-red-400">Error: {error}</p>
            ) : generatedAnswer ? (
               <div className="markdown-content">
                 <ReactMarkdown>{generatedAnswer}</ReactMarkdown>
               </div>
            ) : hasPredefinedAnswer ? (
               <div className="markdown-content">
                 <ReactMarkdown>{question.answer_text || ''}</ReactMarkdown>
               </div>
            ) : (
              <p className="italic text-gray-500">No pre-defined answer...</p>
            )}
            {/* Progress bar section */}
            {!isGenerating &&
             ((hasPredefinedAnswer && question.answer_text) || generatedAnswer) && (
              <div className="mt-4 pt-2 border-t border-gray-200 dark:border-gray-700">
                {/* ... (Progress bar elements) ... */}
              </div>
            )}
          </div> {/* Closing div for answer content */}
        </div> // Closing div for isExpanded block
      )} 
    </div> // Closing div for the main component
  );
}